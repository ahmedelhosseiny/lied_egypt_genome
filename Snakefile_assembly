#kate:syntax python;

from global_variables import *


################################################################################
##### Constructing an assembly using Pacbio data only ##########################
################################################################################


rule symlink_pacbio:
    output: directory("data/01.pacbio")
    shell: "ln -s /data/lied_egypt_genome/raw/P101HW18010820-01_human_2018.08.29/00.data/01.pacbio {output}"

# Making some stats about the overall number of bases etc.
rule pb_bamstats:
    input: "data/01.pacbio/{pb_files}.subreads.bam"
    output: "pacbio/{pb_files}.bamstats"
    shell: "samtools stats {input} > {output}"

rule pb_bamstats_all:
    input: expand("pacbio/{pb_files}.bamstats", \
            pb_files = [item for subl in PACBIO_SAMPLES_TO_SEQRUN_PATH.values() \
                       for item in subl])

# Conversion of bam to fasta sequences
rule pb_bam2fasta:
    input: "data/01.pacbio/{pb_files}.subreads.bam"
    output: temp("pacbio/{pb_files}.fa")
    shell: "samtools fasta -t {input} > {output}"

# Constructing one large fasta file
rule pb_combined_fasta:
    input: expand("pacbio/{pb_files}.fa", \
            pb_files = [item for subl in PACBIO_SAMPLES_TO_SEQRUN_PATH.values() \
                       for item in subl])
    output: "pacbio/pb_EGYPTREF.fa"
    shell: "cat {input} > {output}"

# Run assembler wtdbg2
# WTDBG: De novo assembler for long noisy sequences
# Author: Jue Ruan <ruanjue@gmail.com>
# Version: 2.3 (20181206)
# Usage: wtdbg2 [options] -i <reads.fa> -o <prefix> [reads.fa ...]
# Options:
#  -i <string> Long reads sequences file (REQUIRED; can be multiple), []
#  -o <string> Prefix of output files (REQUIRED), []
#  -t <int>    Number of threads, 0 for all cores, [4]
#  -f          Force to overwrite output files
#  -x <string> Presets, comma delimited, []
#             rsII/rs: -p 21 -S 4 -s 0.05 -L 5000
#           sequel/sq
#        nanopore/ont:
#             (genome size < 1G)  -p 0 -k 15 -AS 2 -s 0.05 -L 5000
#             (genome size >= 1G) -p 19 -AS 2 -s 0.05 -L 5000
#       corrected/ccs: -p 21 -k 0 -AS 4 -K 0.05 -s 0.5
#              Example: '-e 3 -x ont -S 1' in parsing order, -e will be 3, -S will be 1
#  -g <number> Approximate genome size (k/m/g suffix allowed) [0]
#  -X <float>  Choose the best <float> depth from input reads(effective with -g) [50]
#  -L <int>    Choose the longest subread and drop reads shorter than <int> (5000 recommended for PacBio) [0]
#              Negative integer indicate keeping read names, e.g. -5000.
#  -k <int>    Kmer fsize, 0 <= k <= 25, [0]
#  -p <int>    Kmer psize, 0 <= p <= 25, [21]
#              k + p <= 25, seed is <k-mer>+<p-homopolymer-compressed>
#  -K <float>  Filter high frequency kmers, maybe repetitive, [1000.05]
#              >= 1000 and indexing >= (1 - 0.05) * total_kmers_count
#  -E <int>    Min kmer frequency, [2]
#  -S <float>  Subsampling kmers, 1/(<-S>) kmers are indexed, [4.00]
#              -S is very useful in saving memeory and speeding up
#              please note that subsampling kmers will have less matched length
#  -l <float>  Min length of alignment, [2048]
#  -m <float>  Min matched length by kmer matching, [200]
#  -A          Keep contained reads during alignment
#  -s <float>  Min similarity, calculated by kmer matched length / aligned length, [0.05]
#  -e <int>    Min read depth of a valid edge, [3]
#  -q          Quiet
#  -v          Verbose (can be multiple)
#  -V          Print version information and then exit
#  --help      Show more options
# Parameters according to web site (https://github.com/ruanjue/wtdbg2)
# Dataset 	GSize 	Cov 	Asm options 	CPU asm 	CPU cns 	Real tot 	RAM
# Human HG00733 	3Gb 	PB x93 	-x sq -g3g -t47 	2114h26m 	152h24m 	52h22m 	338.1G
rule assembl_with_wtdbg2:
    input: "pacbio/pb_EGYPTREF.fa"
    output: "assembly_wtdbg2/EGYPTREF_wtdbg2.ctg.lay.gz"
    conda: "envs/wtdbg.yaml"
    params: out_base=lambda wildcards, output: output[0][:-11]
    shell: "wtdbg2 -i {input} " + \
                 " -x sq -g 3g -t 31 " + \
                 " -o {params.out_base} "

# WTPOA-CNS: Consensuser for wtdbg using PO-MSA
# Author: Jue Ruan <ruanjue@gmail.com>
# Version: 2.3
# Usage: wtpoa-cns [options]
# Options:
#  -t <int>    Number of threads, [4]
#  -d <string> Reference sequences for SAM input, will invoke sorted-SAM input mode
#  -u          Only process reference regions present in/between SAM alignments
#  -r          Force to use reference mode
#  -p <string> Similar with -d, but translate SAM into wtdbg layout file
#  -i <string> Input file(s) *.ctg.lay from wtdbg, +, [STDIN]
#              Or sorted SAM files when having -d
#  -o <string> Output files, [STDOUT]
#  -f          Force overwrite
#  -j <int>    Expected max length of node, or say the overlap length of two adjacent units in layout file, [1500] bp
#  -b <int>    Bonus for tri-bases match, [0]
#  -M <int>    Match score, [2]
#  -X <int>    Mismatch score, [-5]
#  -I <int>    Insertion score, [-2]
#  -D <int>    Deletion score, [-4]
#  -H <float>  Homopolymer merge score used in dp-call-cns mode, [-3]
#  -B <int>    Bandwidth, [96]
#  -W <int>    Window size in the middle of the first read for fast align remaining reads, [200]
#              If $W is negative, will disable fast align, but use the abs($W) as Band align score cutoff
#  -w <int>    Min size of aligned size in window, [$W * 0.5]
#              In sorted-SAM input mode, -w is the sliding window size [2000]
#  -A          Abort TriPOA when any read cannot be fast aligned, then try POA
#  -S <int>    Shuffle mode, 0: don't shuffle reads, 1: by shared kmers, 2: subsampling. [1]
#  -R <int>    Realignment bandwidth, 0: disable, [16]
#  -c <int>    Consensus mode: 0, run-length; 1, dp-call-cns, [0]
#  -C <int>    Min count of bases to call a consensus base, [3]
#  -F <float>  Min frequency of non-gap bases to call a consensus base, [0.5]
#  -N <int>    Max number of reads in PO-MSA [20]
#              Keep in mind that I am not going to generate high accurate consensus sequences here
#  -x <string> Presets, []
#              sam-sr: polishs contigs from short reads mapping, accepts sorted SAM files
#                      shorted for '-w 200 -j 150 -R 0 -b 1 -c 1 -N 50 -rS 2'
#  -v          Verbose
#  -V          Print version information and then exit
rule consensus_with_wtdbg2:
    input: "assembly_wtdbg2/EGYPTREF_wtdbg2.ctg.lay.gz"
    output: "assembly_wtdbg2/EGYPTREF_wtdbg2.ctg.lay.fa"
    conda: "envs/wtdbg.yaml"
    shell: "wtpoa-cns -i {input} " + \
                    " -t 31 " + \
                    " -o {output}"


################################################################################
##### Correcting / improving / scaffolding the assembly using 10X data #########
################################################################################


rule symlinking_and_renaming_fastq:
    input: "/data/lied_egypt_genome/raw/P101HW18010820-01_human_2018.08.29/00.data/03.10X/{lib}_L{lane}_{readnumber}.fq.gz"
    output: "10x/{lib}_S1_L00{lane}_R{readnumber}_001.fastq.gz"
    shell: "ln -s {input} {output}"

rule symlinking_and_renaming_fastq_all:
    input: expand("10x/{name}.fastq.gz", \
           name = [x.split("_")[0]+"_S1_L00"+x.split("_")[1][1]+"_R1_001" for x in ILLUMINA_10X_LIBS]+ \
                  [x.split("_")[0]+"_S1_L00"+x.split("_")[1][1]+"_R2_001" for x in ILLUMINA_10X_LIBS])

rule run_longranger_basic:
    input: expand("10x/{{lib}}_S1_L00{lane}_R{readnumber}_001.fastq.gz", \
                  lane=[4,5,6,7], readnumber=[1,2])
    output: "longranger/longranger_{lib}/outs/barcoded.fastq.gz",
            "longranger/longranger_{lib}/outs/summary.csv"
    shell: "software2/longranger-2.2.2/longranger basic " + \
           "--id longranger_{wildcards.lib} " + \
           "--fastqs 10x " + \
           "--sample {wildcards.lib}; " + \
           "mv longranger_{wildcards.lib} longranger/.; "

rule run_longranger_basic_all:
    input: expand("longranger/longranger_{lib}/outs/barcoded.fastq.gz", \
           lib = [x.split("_")[0] for x in ILLUMINA_10X_LIBS])

rule index_assembly_for_tigmint:
    input: "assembly_wtdbg2/EGYPTREF_wtdbg2.ctg.lay.fa"
    output: "tigmint/EGYPTREFWTDBG2.fa",
            "tigmint/EGYPTREFWTDBG2.fa.fai"
    conda: "envs/tigmint.yaml"
    shell: "cp {input} {output[0]}; " + \
           "samtools faidx {output[0]}"

rule bwa_index_for_tigmint:
    input: "tigmint/EGYPTREFWTDBG2.fa",
           "tigmint/EGYPTREFWTDBG2.fa.fai"
    output: "tigmint/EGYPTREFWTDBG2.fa.amb",
            "tigmint/EGYPTREFWTDBG2.fa.ann",
            "tigmint/EGYPTREFWTDBG2.fa.bwt",
            "tigmint/EGYPTREFWTDBG2.fa.pac",
            "tigmint/EGYPTREFWTDBG2.fa.sa"
    conda: "envs/tigmint.yaml"
    shell: "bwa index {input[0]}"

rule bwa_mapping_for_tigmint:
    input: "tigmint/EGYPTREFWTDBG2.fa",
           "longranger/longranger_{lib}/outs/barcoded.fastq.gz",
           "tigmint/EGYPTREFWTDBG2.fa.sa"
    output: "tigmint/{lib}.reads.sortbx.bam"
    conda: "envs/tigmint.yaml"
    shell: "bwa mem -t8 -p -C {input[0]} {input[1]} |" + \
           "samtools sort -@8 -tBX -o {output}"

rule merge_bam_files_for_tigmint:
    input: expand("tigmint/{lib}.reads.sortbx.bam", \
           lib = [x.split("_")[0] for x in ILLUMINA_10X_LIBS])
    output: "tigmint/draft.reads.sortbx.bam"
    conda: "envs/tigmint.yaml"
    shell: "samtools merge -tBX {output[0]} {input}"